Serilog
=======

In this article, we'll go through Serilog and it’s implementation. By default, ASP.NET Core comes with some basic logging features built-in. 
You must have seen the ILogger interface throughout .NET Core application demos.  Serilog is used if we want more control over how and where 
to log the details? That is where Logging Frameworks come into play. Out of all of them, Serilog is one of the most popular Libraries for 
.NET Core applications. 

What is Serilog?
----------------

Serilog is a third-party logging library that plugs into the default ILogger of our application with its own implementations. 
It enables the developers to log the events into various destinations like console, file, database, and more. 
Now, if you are already using a database in your .NET Core application, logging events to a database can be a good option. 
Serilog supports structured logging, which allows more details and information about the event to be logged. 
With structured logging in place, you could use these logs to debug in a very logical way.

Setup
-----

To implement Serilog on an .NET Core WebApplication (Razor Pages). Since our focus is on logging and understanding various related concepts, 
we will keep the project setup simple and straight-forward. 

Logging with the Default Logger
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

As I had mentioned earlier, .NET Core applications ship with a default built-in logging system which includes some basic logging functions. 
To understand logging, let’s see how the basic logger works. Once you have created your WebApplication solution, navigate to Pages/Index.cshtml/Index.cshtml.cs. 
You can see the constructor injection of the ILogger interface. This is the default logger from Microsoft.

In the OnGet method of the IndexModel, let’s add a way to demonstrate logging and also use the try-catch block. 
Here I will throw a Dummy Exception so that we can understand logging better. Also note that we will not be 
changing anything on the class further in this demonstration.

.. code-block:: csharp

    public void OnGet()
    {
        _logger.LogInformation("Requested the Index Page");
        int count;
        try
        {
            for(count = 0;count<=5;count++)
            {
                if(count==3)
                    throw new Exception("RandomException");
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex,"Exception Caught");
        }
    }

The OnGet method is fired every time you request for the Index Page (Home Page). So, as the code suggests, I am logging
a message that says “Requested the Index Page” every time you request for this page. After that it runs a loop 5 times, 
and if the iteration count is 3, it throws a dummy exception “RandomException” which in turn gets caught in the catch block. 
This is logged as an error. This way, we have a function that mimics a practical production level function.

Log Levels
----------

Logging Levels are the fundamental concept of logging. When we wrote ‘_logger.LogInformation(“Requested the Index Page”);’, we mentioned 
to the application that this is a log with the log-level set to **Information**. Log levels make sense because it allows you to define
the type of log. Is it a critical log? just a debug message? a warning message?

There are 6 log-levels included:

 * **Trace** – Detailed messages with sensitive app data.
 * **Debug** – Useful for the development environment.
 * **Information** – General messages, like the way we mentioned earlier.
 * **Warning** – For unexpected events.
 * **Error** – For exceptions and errors.
 * **Critical** – For failures that may need immediate attention.
 
Note that Serilog may or may not have the same names for each level.

Default Log Settings
^^^^^^^^^^^^^^^^^^^^

The default settings for our logger is mentioned in appsettings.json. These settings allows you to define on what level of logs you need
from a particular component. For example, any log messages that is generated by the application (Microsoft) with levels Warning and above
is logged to the console. This is the basic idea of log settings.

.. code-block:: json

    {
        "Logging": {
            "LogLevel": {
                "Default": "Information",
                "Microsoft": "Warning",
                "Microsoft.Hosting.Lifetime": "Information"
            }
        }
    }

With that out the way, let’s start the actual implementation of Serilog in our .NET Core application.

Serilog Enrichers
^^^^^^^^^^^^^^^^^

To enable Structured Logging and to unleash the full potential of Serilog, we use enrichers. These enrichers give you additional
details like Machine Name, ProcessId, Thread Id when the log event had occurred for better diagnostics. 
It makes a developer’s life quite simple. We will use the enrichers later in this guide.

Serilog Sinks
^^^^^^^^^^^^^

Serilog Sinks in simpler words relate to destinations for logging the data. In the packages that we are going to install to our .NET Core application, 
Sinks for Console and File are included out of the box. That means we can write logs to Console and File System without adding any extra packages. 
Serilog supports various other destinations like MSSQL, SQLite, SEQ and more.

Installing the Required Packages
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For now, these are the packages that you require. Install them via the NuGet Package Manager or Console.

.. code-block:: rst

    Install-Package Serilog.AspNetCore
    Install-Package Serilog.Settings.Configuration
    Install-Package Serilog.Enrichers.Environment
    Install-Package Serilog.Enrichers.Process
    Install-Package Serilog.Enrichers.Thread

Configuring Serilog
^^^^^^^^^^^^^^^^^^^

Our intention is to use Serilog instead of the default logger. For this, we will need to configure Serilog at the entry point of our .NET Core Application,
i.e. the Program.cs file. Navigate to Program.cs and make the following changes;

.. code-block:: csharp

    public static IHostBuilder CreateHostBuilder(string[] args) =>
        Host.CreateDefaultBuilder(args)
            .UseSerilog() //Uses Serilog instead of default .NET Logger
            .ConfigureWebHostDefaults(webBuilder =>
            {
                webBuilder.UseStartup<Startup>();
            });

.. code-block:: csharp

    public static void Main(string[] args)
    {
        //Read Configuration from appSettings
        var config = new ConfigurationBuilder()
            .AddJsonFile("appsettings.json")
            .Build();
        //Initialize Logger
        Log.Logger = new LoggerConfiguration()
            .ReadFrom.Configuration(config)
            .CreateLogger();

        try
        {
            Log.Information("Application Starting.");
            CreateHostBuilder(args).Build().Run();
        }
        catch (Exception ex)
        {
            Log.Fatal(ex, "The Application failed to start.");
        }
        finally
        {
            Log.CloseAndFlush();
        }        
    }

Setting up Serilog
^^^^^^^^^^^^^^^^^^

Navigate to appsettings.json and remove the default logging settings and replace it with the following.

.. code-block:: json

    {
        "AllowedHosts": "*",
        "Serilog": 
        {
            "Using": [],
            "MinimumLevel": {
            "Default": "Information",
            "Override": 
            {
                "Microsoft": "Warning",
                "System": "Warning"
            }
        },
        "WriteTo": [
        {
            "Name": "Console"
        },
        {
            "Name": "File",
            "Args": {
            "path": "D:\\Logs\\log.txt",
            "outputTemplate": "{Timestamp} {Message}{NewLine:1}{Exception:1}"
            }
        }],
        "Enrich": [
            "FromLogContext",
            "WithMachineName",
            "WithProcessId",
            "WithThreadId"
        ],
        "Properties": {
            "ApplicationName": "Serilog.WebApplication"
        }
    }

